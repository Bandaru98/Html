
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
</html>




<!-- // two type of declaration
// (1) Constructor // (2) Literal

// (1) Constructor // Singleton //
// Object.create()
// const user = new Object() 

// (2) Object Literal
const mySym = Symbol("key1");

const user = {
    name: "Suraj", // key assume as a string - "name"
    "full name": "Suraj Kumar",
    //mySym:"mykey1", // value is same but dataType is a string
    [mySym]: "mykey1",
    age: 33,
    city: "Banglore",
    emailId: "suraj28j@gamil.com",
    isLoggedIn: false,
    lastLogInDays: ["Monday", "Tuesday", "Wednesday"]
}

// there are two type to access the object
console.log(user.name);
console.log(user["name"]);

console.log(user["full name"]);

// we can change the value 
user.name = "Anand";
//console.log(user);

//Object.freeze(user); // we can not change the value

user.welcome = function () {
    console.log("welcome JS User");
}

console.log(user.welcome); // pass the function referance not excute
console.log(user.welcome()); // function excute
user.welcome();

User.welcome2 = function(){
    console.log("Welcome JS User "+this.name); // this referance to that Object 
}

// Object Merge or assign

const obj1 = { 1: "a", 2: "b" }
const obj2 = { 3: "c", 4: "d" }
//const obj3 = Object.assign(obj1, obj2);
//const obj3 = Object.assign({}, obj1, obj2); //Object.assign(target, sources)
const obj3 = { ...obj1, ...obj2 };

console.log(obj3);


// Some other Object Properties //
const newUser = {
    name: "Satish",
    age: 30,
    city: "Varanasi",
    id: "sat94@gmail.com"
}

console.log(Object.keys(newUser)); // return value in arryay data type
console.log(Object.values(newUser)); // return array data type
//console.log(Object.entries(newUser));
console.log(newUser.hasOwnProperty("city"));



// Object de-structure //

const student = {
    name: "Rakesh",
    age: 33,
    qualification: "Diploma",
    workingExperince: "2 Years"
}

// const {workingExperince}=student;
// console.log(workingExperince);

const { workingExperince: exp } = student;
console.log(exp);



// Object Descripter //

console.log(Math.PI);
Math.PI = 5; // try to change the value 
console.log(Math.PI);

const mathDescripter = Object.getOwnPropertyDescriptor(Math, "PI");
console.log(mathDescripter);
/*
{
  value: 3.141592653589793,
  writable: false,
  enumerable: false,
  configurable: false
}   
*/

const mobile = {
    model_No: "SM-Galaxy_M14",
    price: 14000,
    isAvailable: true
}

const mobileDes = Object.getOwnPropertyDescriptor(mobile, "model_No")
console.log(mobileDes);
/*
{
  value: 'SM-Galaxy_M14',
  writable: true,
  enumerable: true,
  configurable: true
}
*/
Object.defineProperty(mobile, "model_No", {
    writable: false,
    enumerable: false,
})
const mobileDesChange = Object.getOwnPropertyDescriptor(mobile, "model_No")
console.log(mobileDesChange);


//-------------------
class user {
    constructor(username, emailId, password) {
        this.username = username,
            this.emailId = emailId,
            this.password = password
    }
    encrptPassword() {
        return (`${this.password}abc`)
    }
    changeUserName() {
        return `${this.username.toUpperCase()}`
    }
}

const emp1 = new user("Sanjay", "sanjay1995@gmail.com", 123);
console.log(emp1.encrptPassword());
console.log(emp1.changeUserName());


// behind the scene

const userNew = function(username,emailId,password){
    this.username = username,
    this.emailId = emailId,
    this.password = password
}

userNew.prototype.encrptPasswordNew = function(){
    return `${this.password}abc`
}

userNew.prototype.changeUserNameNew = function(){
    return `${this.username.toUpperCase()}`
}

const emp2 = new userNew("Himanshu","hima@1995gmail.com",321);

console.log(emp2.encrptPasswordNew());
console.log(emp2.changeUserNameNew());

//-----------------------------
// Construction Function //

const User = function (name, id, isLoggedIn) {
    this.name = name; // in coding practice function veriable and function parameters must be same
    this.id = id;
    this.isLoggedIn = isLoggedIn;
    return this
}

let user1 = new User("Suraj", 101, true); // 'new' keyword call a construction function
let user2 = new User("Mohit", 20, false); // user2 values over wright 'User' 
//console.log(user1);
console.log(user2);
//-----------------------------
// prototype is JavaScript behaviour

function multiplyBy5(num) {
    return num * 5;
}

multiplyBy5.power = 2;

console.log(multiplyBy5(5));
console.log(multiplyBy5.power);
console.log(multiplyBy5.prototype); // return {}
// emplty {} refer to this methode -by default contest set 

function createUser(username, score) {
    this.username = username;
    this.score = score;
}

// with the help of 'prototype' we can inject a methode (functionality) in our function 

createUser.prototype.increment = function () {
    this.score++;
}
createUser.prototype.printMe = function () {
    console.log(`price is ${this.score}`)
}

const tea = new createUser("tea", 20);
const coffee = new createUser("coffee", 50);

//console.log(createUser.prototype); // ...for checking the methode is inject or not

tea.printMe();

/* 

Here's what happens behind the scenes when the new keyword is used:

A new object is created : The new keyword initiates the creation of a new JavaScript object.

A prototype is linked: The newly created object gets linked to the prototype property of the constructor function.
this mean that it has access to properties and method defined on the constructor's prototype.

The constructor is called: The constructor function is called with the specified arguments and this is bound to the newly created object.
If no explicit return value is specified from the constructor, JavaScript assumes this, the newly created obect, to be the intended return vale.

The new object is returned: After the constructor function has been called, if it doesn't return a non-primitive value (object, array, function etc.), 
the newly created object is returned.

*/


// some other uses of Prototype //

let myHeros = ["thor", "spiderman"]

let heroPower = {
    thor: "hammer",
    spiderman: "sling",

    getSpiderPower: function () {
        console.log(`Spidy power is ${this.spiderman}`);
    }
}

Object.prototype.welcome = function () {
    console.log(`Welcome to the coding world`);
}
// the welcome methode can access both Array and Object 

myHeros.welcome();
heroPower.welcome();


Array.prototype.myArray = function () {
    console.log(`This is Array Prototype`);
}
// the myArray methode can access only Arrays

myHeros.myArray();
// heroPower.myArray(); // heroPower.myArray is not a function // Object can't access  only Array can



// prototype inheritance //

let obj1 = {
    name: "Himanshu",
    id: 101,
    skill: function () {
        console.log(`${this.name}'s communication skill is very nice`);
    }
}

let obj2 = {
    name: "Manish",
    id: 102,
    // __proto__: obj1
}

// obj2.__proto__ = obj1;

// modern syntex

Object.setPrototypeOf(obj2, obj1);

obj2.skill();



// string prototype inheritance //

let studentName = "Suraj    "

String.prototype.trueLength = function () {
    console.log(`${this}`); // the Value  who's call
    console.log(`True lenghth is : ${this.trim().length}`);
}

studentName.trueLength();

"Anand  ".trueLength();
//-----------------------------
let ary = new Array(0, 1, 2, 3, 4);
//ary.push(5)
//console.log(ary); // [ 0, 1, 2, 3, 4, 5 ]

ary.pop();
//console.log(ary); // [ 0, 1, 2, 3 ]

let ary1 = [0, 1, 2, 3, 4]
//console.log(ary1); // [0, 1, 2, 3, 4]



let arySlice = ary1.slice(1, 3) // Slice
//console.log("Array Slice => ",arySlice); // [1, 2]
//console.log("Orignal Array after slice => ",ary1); // [0, 1 ,2, 3, 4]

let arySplice = ary1.splice(1, 3) // Splice 
//console.log("Array Splice => ",arySplice); // [1, 2, 3]
//console.log("Orignal Array after splice => ",ary1); // [0, 4]


let ary2 = [11, 12, 15, 16];
ary2.splice(2, 0, 13, 14); // Splice
//console.log(ary2); // [11, 12, 13, 14, 15, 16]



let aisa = ["India", "Sri Lanka", "Nepal"];
let africa = ["Kenya", "Namibia", "Zimbabwe"];

//aisa.push(africa);
//console.log(aisa); // [ 'India', 'Sri Lanka', 'Nepal', [ 'Kenya', 'Namibia', 'Zimbabwe' ] ]

let asaf = aisa.concat(africa);
//console.log(asaf); // [ 'India', 'Sri Lanka', 'Nepal', 'Kenya', 'Namibia', 'Zimbabwe' ]

let asNaf = [...aisa, ...africa];
//console.log(asNaf);


let subAry = [1, 2, 3, [4, 5], 6, 7, [8, [9, 10]]];
let subAry_new = subAry.flat(Infinity);
console.log(subAry_new);

console.log(Array.isArray("Suraj"));
console.log(Array.from("Suraj"));

console.log(Array.from({ name: "Suraj" }));


let score1 = 100;
let score2 = 200;
let score3 = 300;

console.log(Array.of(score1, score2, score3));
//-------------------
// call() , apply() and blind() //
let obj1 = {
    fname: "Suraj",
    lname: "Kumar",
    age: 32,
    fullname: function () {
        console.log(this.fname + " " + this.lname);
    }
}
let obj2 = {
    fname: "Prakash",
    lname: "Kumar",
    age: 29
}
// function borrowing
//obj1.fullname.call(obj2);
function fulldeails() {
    //console.log("Name"+":"+this.fname+" "+this.lname+" "+"Age"+":"+this.age);
    console.log(`Name : ${this.fname} ${this.lname} Age : ${this.age}`);
}

//fulldeails.call(obj1);
function userdetails(city, state) {
    console.log(`Hello My self ${this.fname} ${this.lname} and I live in ${city} (${state})`);
}
userdetails.call(obj1, "Renukoot", "Uttar_Pradesh"); // call()
userdetails.apply(obj2, ["Bangalore", "Karnatka"]); //apply()
// blind 
let userfun = userdetails.bind(obj1, "Praygraj", "Uttar_Pradesh");
userfun();



// Regular Expression // 
let pattern = /raj/i;
let string = "Suraj";
console.log(pattern.exec(string));

let pattern2 = /[a-z][0-9]/g;
let string2 = "s2810j";
console.log(pattern2.test(string2));



// Currying //

// Closures
function add(a) {
    return function (b) {
        return function (c) {
            return a + b + c;
        }
    }
}
// let data1=add(2);
// let data2=data1(3);
// let data3=data2(4);
let data = add(2)(3)(4);  // value of a retain it call lexical scope 
console.log(data); // Currying

let userObj = {
    name: "Suraj",
    age: 33
}

function userinfo(obj) {
    return function (info) {
        return obj[info];
    }
}
let res = userinfo(userObj);
console.log(res('name'));



// Callback Function //
function username() {
    console.log("Suraj");
}
function fun(callback) {
    callback();
}
fun(username);

// Callback Function //
function intro(age) {
    console.log("My name is Suraj & I'm " + age + " years old");
}
function userinfo(a, cb) {
    cb(a);
}
userinfo(33, intro);



// Memoization //
let sum = 0;
function cal(n) {
    for (let i = 0; i <= n; i++) {
        sum += i;
    }
    return sum;
}
const memoize = (fun) => {
    let cache = {};
    return function (...arg) {
        let n = arg[0];
        if (n in cache) {
            console.log("cache");
            return cache[n];
        } else {
            console.log("calculating first time");
            let result = fun(n);
            cache[n] = result;
            return result;
        }
    }
}
console.time();
const eff = memoize(cal);
console.log(eff(5));
console.timeEnd();



// Constructor //
function Cons(name, city,) {
    this.name = name;
    this.city = city;
}
let user = new Cons("Suraj", "Renukoot");
console.log(user);


// Prototype //
function mobile(model_no, Price) {
    // Instant Member
    this.model = model_no;
    this.price = Price;
};
let samsung = new mobile("Galaxy", 15000);
let nokia = new mobile(3310, 10000)

// Prototype Member
// samsung.color="white";
// nokia.color="white";
// classname.prototype.key="value";
mobile.prototype.color = "white";

console.log(samsung);
console.log(nokia);


// Class //

class student {
    constructor(name, age) {
        this.studentname = name;
        this.studentage = age;
    }
    details() {
        console.log(`Student name is ${this.studentname} and its age is ${this.studentage}`);
    }
    static st() {
        console.log("This is static methods");
    }
}
let rollNo1 = new student("Suraj", 33);
rollNo1.details();
student.st();



// Promise //

let prom=new Promise(function(res,rej){
    if(1){
        res("Successful");
    }else{
        rej("Failed");
    }
})
let onfullfilment=(result)=>{
    console.log(result);
}
let onreject=(error)=>{
    console.log(error);
}
prom.then(onfullfilment);
prom.catch(onreject);



// Generator Function //

function *fun(){
    console.log("First Message");
    yield 'Yied No 1';
    console.log("Second Message");
    yield 'Yied No 2';
    console.log("Third MEssage");
    yield 'Yied No 3';
}
let gen=fun();
console.log(gen.next());
//-----------------------------

// The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value. 

const promiseOne = new Promise(function (resolve, reject) {
    // Do async task
    // DB Call, Network, cryptograph
    setTimeout(function () {
        console.log("Async task is complete");
        resolve()
    }, 1000)
})

promiseOne.then(function () {
    console.log("Promised Consumed");
})



new Promise(function (resolve, reject) {
    setTimeout(function () {
        console.log("Async task2 is complete");
        resolve()
    }, 1000)
}).then(function () {
    console.log("Async Task2 resolve");
})



const promiseThree = new Promise(function (resolve, reject) {
    setTimeout(function () {
        resolve({ username: "Suraj Kumar", email: "sk@gmail.com" })
    }, 1000)
})

promiseThree.then(function (user) {
    console.log(user);
})



const promiseFour = new Promise(function (resolve, reject) {
    setTimeout(function () {
        let error = false;
        if (!error) {
            resolve({ username: "SURAJ KUMAR", email: "sk123@gmail.com" })
        } else {
            reject("Error: Something went wrong")
        }
    }, 1000)
})

promiseFour.then((user) => {
    console.log(user);
    return user.username
}).then((username) => {  // first then return value is recive by second than
    console.log(username);
}).catch((Error) => {
    console.log(Error);
}).finally(() => {
    console.log("The promise is either resolved or rejected");
})




const promiseFive = new Promise(function (resolve, reject) {
    setTimeout(function () {
        let error = false;
        if (!error) {
            resolve({ username: "JavaScript", password: 123 })
        } else {
            reject("Error: Something went wrong")
        }
    }, 1000)
});

async function consumePromiseFive() {
    try {
        const response = await promiseFive
        console.log(response);
    } catch (error) {
        console.log(error);
    }
}

consumePromiseFive()

//-----------------------------
// ----Problem---- //
// console.log("Start");
// function getName(name){
//     setTimeout(()=>{
//         console.log("Inside SetTimeOut");
//         console.log(name);
//     },2000);
// }
// const nm = getName("Suraj");
// console.log(nm);
// console.log("End");

//----Solution---- // .....with  callback funtion (construction function)
// console.log("Start");
// function getName(name ,cb){
//     setTimeout(()=>{
//         console.log("Inside SetTimeOut");
//         cb(name);
//     },2000);
// }
// getName("Suraj" ,(nm)=>{console.log(nm)});
// console.log("End");




// console.log("Start");
// function getName(name, cb) {
//     setTimeout(() => {
//         console.log("Inside Name SetTimeOut");
//         cb(name);
//     }, 2000);
// }
// function getHobbies(name, cb) {
//     setTimeout(() => {
//         console.log("Inside Hobbies SetTimeOut");
//         cb(["Cricket", "Hockey", "Football"]);
//     },1000)
// }
// getName("Suraj", (nm) => { console.log(nm), getHobbies(nm, (hobby) => { console.log(hobby) }) });
// console.log("End");




// with Promise //
// let prom = new Promise((res,rej)=>{
//     let x=true;
//     if(!x){
//         res("Solved");
//     }else{
//         rej("Reject");
//     }
// }).then((value)=>{
//     console.log(value);
// }).catch((value)=>{
//     console.log(value);
// }).finally(()=>{
//     console.log("Cleaned");
// })




// another way to promise produce//
function getName(name) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log("Inside Name SetTimeOut");
            resolve(name);
        }, 2000);
    })
}

function getHobbies(name) {
    return new Promise((resolve,reject)=>{
        setTimeout(() => {
            console.log("Inside Hobbies SetTimeOut");
            resolve(["Cricket", "Hockey", "Football"]);
        },1000)
    }) 
}

// promise consume //
// getName("Suraj")
// .then((nm)=>getHobbies(nm))
// .then((hobby)=>console.log(hobby))


// another way to consume promise //
// async function showHobbies(){
//     let nm = await getName("Suraj")
//     let hobby = await getHobbies(nm);
//     console.log(hobby);
// }


// (async and awit) consume promise with error handling //
async function showHobbies(){
    try{
        let nm = await getName("Suraj")
    let hobby = await getHobbies(nm);
    console.log(hobby);
    }catch{
        console.log("Something wrong");
    }
    
}

 showHobbies();
 //-------------------
 
/*
const   |   let   |   var
------------------------------------------------
global scope    |    No     |    No   |   Yes
------------------------------------------------
function scope  |    Yes    |   Yes   |   Yes 
------------------------------------------------
block scope     |    Yes    |   Yes   |   No
------------------------------------------------
reassigned      |     No    |   Yes   |   Yes

*/


var v1 = 23;
let l1 = 28;
const c1 = 11;

function globalscope(){
console.log(v1);
console.log(l1);
console.log(c1);
}
globalscope();  // All variables can be accessed anywhere since they are declared in the global scope




// Function Scope //

function funscope(){
var v2 = 30;
let l2 = 40;
const c2 = 50;
}
console.log(v2);  // Throws an error
console.log(l2);  // Throws an error
console.log(c2);  // Throws an error




// Block Scope //

{
var v3 = 100;
let l3 = 110;
const c3 = 120;
}

console.log(v3); // Output is 100
console.log(l3); // Throws an error
console.log(c3); // Throws an error










// Hoisting //

// Hoisting is the default behaviour of javascript where all the variable and function declarations are moved on top //

// Example 1

num1 = 28; 
console.log(num1);// outputs 28 even when the variable is declared after it is initialized	
var num1;



// Example 2
welcome();

function welcome(){
console.log("Hosting is JavaScript");
}



// Temporal Dead Zone //

// Temporal Dead Zone is a behaviour that occurs with variables declared using let and const keywords. 
// It is a behaviour where we try to access a variable before it is initialized. Examples of temporal dead zone 

// Example 

num2 = 29; // Cannot access 'num2' before initialization
console.log(num2);	
let num2; 
// same as const 
//------------------- -->